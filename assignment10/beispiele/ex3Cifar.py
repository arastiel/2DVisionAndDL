# -*- coding: utf-8 -*-
"""CIFAR_2DVIS

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wNsLYBcHGczTtajg7mHMDEdlYNNtwp18
"""

import torch
import torchvision
import torchvision.transforms as transforms

import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

from tqdm import tqdm


class CovNetBatchNorm(nn.Module):
    def __init__(self):
        super(CovNetBatchNorm, self).__init__()
        # (1,1) Padding for the Convolution
        # (2,2) Stride to match the given dimensions
        self.conv1 = nn.Conv2d(3, 128, 3, stride=(2, 2), padding=(1, 1))  # -> (128,16,16)
        self.batch_norm1 = nn.BatchNorm2d(128)
        self.pool1 = nn.MaxPool2d((2, 2), (2, 2))  # (128,8,8)
        self.conv2 = nn.Conv2d(128, 512, 3, padding=(1, 1))  # -> (512,8,8)
        self.batch_norm2 = nn.BatchNorm2d(512)
        self.pool2 = nn.MaxPool2d((2, 2), (2, 2))  # -> (512,4,4)
        self.conv3 = nn.Conv2d(512, 512, 3, padding=(1, 1))  # -> (512,4,4)
        self.batch_norm3 = nn.BatchNorm2d(512)
        self.pool3 = nn.MaxPool2d((2, 2), (2, 2))  # -> (512,2,2)
        self.conv4 = nn.Conv2d(512, 512, 3, padding=(1, 1))  # -> (512,2,2)
        self.batch_norm3 = nn.BatchNorm2d(512)
        self.pool4 = nn.MaxPool2d((2, 2), (2, 2))  # -> (512,1,1)
        self.fc = nn.Linear(512, 10)  # (10)

    def forward(self, x):
        x = F.relu(self.pool1(self.batch_norm1(self.conv1(x))))
        x = F.relu(self.pool2(self.batch_norm2(self.conv2(x))))
        x = F.relu(self.pool3(self.batch_norm3(self.conv3(x))))
        x = F.relu(self.pool4(self.batch_norm4(self.conv4(x))))
        batch_size = x.shape[0]
        x = x.reshape((batch_size, 512))
        x = self.fc(x)
        return x


def calculate_accuracy(model, dataloader):
    correct = 0
    total = 0
    with torch.no_grad():
        for imgs, labels in tqdm(dataloader):
            outputs = model(imgs)
            _, predicted = torch.max(outputs, dim=1)
            total += labels.shape[0]
            correct += int((predicted == labels).sum())

    return correct / total


def PrintModelSize(model):
    return sum(p.numel() for p in model.parameters())


if __name__ == '__main__':
    transform = transforms.Compose(
        [transforms.ToTensor(),
         transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])

    trainset = torchvision.datasets.CIFAR10(root='./data', train=True,
                                            download=True, transform=transform)
    trainloader = torch.utils.data.DataLoader(trainset, batch_size=4,
                                              shuffle=True, num_workers=2)

    testset = torchvision.datasets.CIFAR10(root='./data', train=False,
                                           download=True, transform=transform)
    testloader = torch.utils.data.DataLoader(testset, batch_size=4,
                                             shuffle=False, num_workers=2)

    classes = ('plane', 'car', 'bird', 'cat',
               'deer', 'dog', 'frog', 'horse', 'ship', 'truck')

    covnet_normal = CovNetBatchNorm()

    # loss_fun = nn.CrossEntropyLoss()
    # optimizer = optim.Adam(covnet_normal.parameters())
    #
    # for epoch in range(2):  # loop over the dataset multiple times
    #
    #     running_loss = 0.0
    #     for i, data in enumerate(tqdm(trainloader, "Running through batches")):
    #         # get the inputs; data is a list of [inputs, labels]
    #         inputs, labels = data
    #
    #         # zero the parameter gradients
    #         optimizer.zero_grad()
    #
    #         # forward + backward + optimize
    #         outputs = covnet_normal(inputs)
    #         loss = loss_fun(outputs, labels)
    #         loss.backward()
    #         optimizer.step()
    #
    #         # print statistics
    #         running_loss += loss.item()
    #         if i % 2000 == 1999:  # print every 2000 mini-batches
    #             print('[%d, %5d] loss: %.3f' %
    #                   (epoch + 1, i + 1, running_loss / 2000))
    #             running_loss = 0.0

    torch.save(covnet_normal.state_dict(), "Batch_Norm_Cifar")

    covnet_normal.load_state_dict(torch.load("Batch_Norm_Cifar"))

    train_set_accuracy = calculate_accuracy(covnet_normal, trainloader)  # 76.912 %
    print(f"Training set accuracy = {train_set_accuracy*100}")

    validation_set_accuracy = calculate_accuracy(covnet_normal, testloader)  # 71.57 %
    print(f"Validation set accuracy = {validation_set_accuracy*100}")

    parameter_count = PrintModelSize(covnet_normal)  # 5321994 Parameters
